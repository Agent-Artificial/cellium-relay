// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AccessToken {
    #[prost(string, tag = "1")]
    pub username: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "2")]
    pub public_key: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag = "3")]
    pub expiration_time: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "4")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RequestAuthInfo {
    #[prost(message, optional, tag = "1")]
    pub client_access_token: ::core::option::Option<AccessToken>,
    #[prost(bytes = "vec", tag = "2")]
    pub service_public_key: ::prost::alloc::vec::Vec<u8>,
    #[prost(double, tag = "3")]
    pub time: f64,
    #[prost(bytes = "vec", tag = "4")]
    pub nonce: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "5")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResponseAuthInfo {
    #[prost(message, optional, tag = "1")]
    pub service_access_token: ::core::option::Option<AccessToken>,
    #[prost(bytes = "vec", tag = "2")]
    pub nonce: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "3")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExpertUid {
    #[prost(string, tag = "1")]
    pub uid: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExpertInfo {
    #[prost(bytes = "vec", tag = "1")]
    pub serialized_info: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExpertRequest {
    #[prost(string, tag = "1")]
    pub uid: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub tensors: ::prost::alloc::vec::Vec<Tensor>,
    #[prost(bytes = "vec", tag = "3")]
    pub metadata: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExpertResponse {
    #[prost(message, repeated, tag = "2")]
    pub tensors: ::prost::alloc::vec::Vec<Tensor>,
    #[prost(bytes = "vec", tag = "3")]
    pub metadata: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Tensor {
    #[prost(bytes = "vec", tag = "1")]
    pub buffer: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint32, repeated, tag = "2")]
    pub size: ::prost::alloc::vec::Vec<u32>,
    #[prost(bool, tag = "3")]
    pub requires_grad: bool,
    #[prost(string, tag = "4")]
    pub dtype: ::prost::alloc::string::String,
    #[prost(enumeration = "CompressionType", tag = "5")]
    pub compression: i32,
    #[prost(int32, tag = "6")]
    pub chunks: i32,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CompressionType {
    None = 0,
    Meanstd16bit = 1,
    Float16 = 2,
    Quantile8bit = 3,
    Uniform8bit = 4,
    Blockwise8bit = 5,
}
impl CompressionType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            CompressionType::None => "NONE",
            CompressionType::Meanstd16bit => "MEANSTD_16BIT",
            CompressionType::Float16 => "FLOAT16",
            CompressionType::Quantile8bit => "QUANTILE_8BIT",
            CompressionType::Uniform8bit => "UNIFORM_8BIT",
            CompressionType::Blockwise8bit => "BLOCKWISE_8BIT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "NONE" => Some(Self::None),
            "MEANSTD_16BIT" => Some(Self::Meanstd16bit),
            "FLOAT16" => Some(Self::Float16),
            "QUANTILE_8BIT" => Some(Self::Quantile8bit),
            "UNIFORM_8BIT" => Some(Self::Uniform8bit),
            "BLOCKWISE_8BIT" => Some(Self::Blockwise8bit),
            _ => None,
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JoinRequest {
    /// A hash that describes follower's tensors (shapes, num tensors, etc)
    #[prost(bytes = "vec", tag = "2")]
    pub schema_hash: ::prost::alloc::vec::Vec<u8>,
    /// Follower would like to **begin** all_reduce by this point in time
    #[prost(double, tag = "3")]
    pub expiration: f64,
    /// optional metadata that is gathered from all peers (e.g. batch size or current loss)
    #[prost(bytes = "vec", tag = "4")]
    pub gather: ::prost::alloc::vec::Vec<u8>,
    /// if True, the incoming averager is a client with no capacity for averaging
    #[prost(bool, tag = "5")]
    pub client_mode: bool,
    /// group key identifying an All-Reduce bucket, e.g my_averager.0b011011101
    #[prost(string, tag = "6")]
    pub group_key: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MessageFromLeader {
    #[prost(enumeration = "MessageCode", tag = "1")]
    pub code: i32,
    /// a unique identifier of this group, only valid until allreduce is finished/failed
    #[prost(bytes = "vec", tag = "2")]
    pub group_id: ::prost::alloc::vec::Vec<u8>,
    /// if peer is already in a group, it'll provide us with a peer id of its leader
    #[prost(bytes = "vec", tag = "3")]
    pub suggested_leader: ::prost::alloc::vec::Vec<u8>,
    /// a sequence of peers, each responsible for one shard during averaging
    #[prost(bytes = "vec", repeated, tag = "4")]
    pub ordered_peer_ids: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    /// metadata (gather) from all groupmates in the same order as their peer ids
    #[prost(bytes = "vec", repeated, tag = "5")]
    pub gathered: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AveragingData {
    /// in case of a protocol violation, this will be the error message
    #[prost(enumeration = "MessageCode", tag = "1")]
    pub code: i32,
    /// a unique group identifier, same as in MessageFromLeader
    #[prost(bytes = "vec", tag = "2")]
    pub group_id: ::prost::alloc::vec::Vec<u8>,
    /// sender's rpc peer_id, used for coordination
    #[prost(bytes = "vec", tag = "3")]
    pub peer_id: ::prost::alloc::vec::Vec<u8>,
    /// either peer's local tensor part (rpc input) or group average of this part (rpc output)
    #[prost(message, optional, tag = "4")]
    pub tensor_part: ::core::option::Option<Tensor>,
    /// peers will be averaged in proportion to these weights
    #[prost(double, tag = "5")]
    pub weight: f64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DownloadRequest {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DownloadData {
    #[prost(bytes = "vec", tag = "1")]
    pub metadata: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "2")]
    pub tensor_part: ::core::option::Option<Tensor>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MessageCode {
    /// Default value that should not be used explicitly
    NoCode = 0,
    /// "Dear maybe leader, will you have me in your group as a follower?"
    RequestJoin = 1,
    /// "I accept you in my group, you now commit to responding to me"
    Accepted = 2,
    /// "We can begin allreduce now. These are your peers."
    BeginAllreduce = 3,
    /// "I am running allreduce with you, here's a part of my tensor that you should aggregate"
    PartForAveraging = 4,
    /// "I aggregated your part with others and here's the average for that part"
    AveragedPart = 5,
    /// "I have not declared my group id yet, how the heck did you even find me? Go away."
    NotDeclared = 6,
    /// "I am not a group a leader. Go ask my leader instead."
    NotALeader = 7,
    /// "I will not accept you. I cannot guarantee that we begin before you expire."
    BadExpirationTime = 8,
    /// "I will not accept you. I am not averaging the samy type of tensors as you."
    BadSchemaHash = 9,
    /// "I will not accept your request, your group id does not match with any groups i'm in."
    BadGroupId = 10,
    /// "I will not accept you, i already have exactly the same peer id in my current group."
    DuplicatePeerId = 11,
    /// "I will not accept you, my group already contains too many peers."
    GroupIsFull = 12,
    /// "I'm not available at the moment. Please, get lost."
    NotLookingForGroup = 13,
    /// "You did something so unspeakable that i don't have a special code for that."
    ProtocolViolation = 14,
    /// "I messed up, we will have to stop allreduce because of that."
    InternalError = 15,
    /// "\[from peer during allreduce\] I no longer want to participate in AllReduce."
    Cancelled = 16,
    /// "\[from leader\] The group is closed. Go find another group."
    GroupDisbanded = 17,
    /// "I will not accept you. My current group key differs (maybe you used my older key)."
    BadGroupKey = 18,
}
impl MessageCode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            MessageCode::NoCode => "NO_CODE",
            MessageCode::RequestJoin => "REQUEST_JOIN",
            MessageCode::Accepted => "ACCEPTED",
            MessageCode::BeginAllreduce => "BEGIN_ALLREDUCE",
            MessageCode::PartForAveraging => "PART_FOR_AVERAGING",
            MessageCode::AveragedPart => "AVERAGED_PART",
            MessageCode::NotDeclared => "NOT_DECLARED",
            MessageCode::NotALeader => "NOT_A_LEADER",
            MessageCode::BadExpirationTime => "BAD_EXPIRATION_TIME",
            MessageCode::BadSchemaHash => "BAD_SCHEMA_HASH",
            MessageCode::BadGroupId => "BAD_GROUP_ID",
            MessageCode::DuplicatePeerId => "DUPLICATE_PEER_ID",
            MessageCode::GroupIsFull => "GROUP_IS_FULL",
            MessageCode::NotLookingForGroup => "NOT_LOOKING_FOR_GROUP",
            MessageCode::ProtocolViolation => "PROTOCOL_VIOLATION",
            MessageCode::InternalError => "INTERNAL_ERROR",
            MessageCode::Cancelled => "CANCELLED",
            MessageCode::GroupDisbanded => "GROUP_DISBANDED",
            MessageCode::BadGroupKey => "BAD_GROUP_KEY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "NO_CODE" => Some(Self::NoCode),
            "REQUEST_JOIN" => Some(Self::RequestJoin),
            "ACCEPTED" => Some(Self::Accepted),
            "BEGIN_ALLREDUCE" => Some(Self::BeginAllreduce),
            "PART_FOR_AVERAGING" => Some(Self::PartForAveraging),
            "AVERAGED_PART" => Some(Self::AveragedPart),
            "NOT_DECLARED" => Some(Self::NotDeclared),
            "NOT_A_LEADER" => Some(Self::NotALeader),
            "BAD_EXPIRATION_TIME" => Some(Self::BadExpirationTime),
            "BAD_SCHEMA_HASH" => Some(Self::BadSchemaHash),
            "BAD_GROUP_ID" => Some(Self::BadGroupId),
            "DUPLICATE_PEER_ID" => Some(Self::DuplicatePeerId),
            "GROUP_IS_FULL" => Some(Self::GroupIsFull),
            "NOT_LOOKING_FOR_GROUP" => Some(Self::NotLookingForGroup),
            "PROTOCOL_VIOLATION" => Some(Self::ProtocolViolation),
            "INTERNAL_ERROR" => Some(Self::InternalError),
            "CANCELLED" => Some(Self::Cancelled),
            "GROUP_DISBANDED" => Some(Self::GroupDisbanded),
            "BAD_GROUP_KEY" => Some(Self::BadGroupKey),
            _ => None,
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodeInfo {
    /// note: both node_id and port are optional: if specified, ask peer to add you to its routing table;
    /// if either node_id or port is absent, simply request recipient info (for client-only mode)
    ///
    /// sender's own node id serialized with DHTID.to_bytes()
    #[prost(bytes = "vec", tag = "1")]
    pub node_id: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PingRequest {
    #[prost(message, optional, tag = "1")]
    pub auth: ::core::option::Option<RequestAuthInfo>,
    /// (optional) sender's own node info, same behavior as in DHT.rpc_ping
    #[prost(message, optional, tag = "2")]
    pub peer: ::core::option::Option<NodeInfo>,
    /// set to True if sender wants to validate that he is accessible and synchronized
    #[prost(bool, tag = "3")]
    pub validate: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PingResponse {
    #[prost(message, optional, tag = "1")]
    pub auth: ::core::option::Option<ResponseAuthInfo>,
    /// respondent's node id, for you to update routing table
    #[prost(message, optional, tag = "2")]
    pub peer: ::core::option::Option<NodeInfo>,
    /// recipient's local DHT time - used to soft-synchronize peers
    #[prost(double, tag = "4")]
    pub dht_time: f64,
    /// if validate = True, this flag asserts that the sender is available for ping
    #[prost(bool, tag = "5")]
    pub available: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StoreRequest {
    #[prost(message, optional, tag = "1")]
    pub auth: ::core::option::Option<RequestAuthInfo>,
    /// three lists of the same length representing dht keys, dht values and expiration
    ///
    /// keys in the form of DHTID.generate(raw_key).to_bytes()
    #[prost(bytes = "vec", repeated, tag = "2")]
    pub keys: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    /// serialized subkeys for DictionaryDHTValue type. None means no subkey
    #[prost(bytes = "vec", repeated, tag = "3")]
    pub subkeys: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    /// serialized value for i-th key
    #[prost(bytes = "vec", repeated, tag = "4")]
    pub values: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    /// expirations for i-th key (type = DHTExpiration)
    #[prost(double, repeated, tag = "5")]
    pub expiration_time: ::prost::alloc::vec::Vec<f64>,
    /// if in_cache\[i\], store i-th key in cache, else store normally
    #[prost(bool, repeated, tag = "6")]
    pub in_cache: ::prost::alloc::vec::Vec<bool>,
    /// (optional) sender's own node info, same behavior as in DHT.rpc_ping
    #[prost(message, optional, tag = "7")]
    pub peer: ::core::option::Option<NodeInfo>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StoreResponse {
    #[prost(message, optional, tag = "1")]
    pub auth: ::core::option::Option<ResponseAuthInfo>,
    /// for every key, True means store accepted, False means store rejected/failed
    #[prost(bool, repeated, tag = "2")]
    pub store_ok: ::prost::alloc::vec::Vec<bool>,
    /// respondent's node id, for you to update routing table
    #[prost(message, optional, tag = "3")]
    pub peer: ::core::option::Option<NodeInfo>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FindRequest {
    #[prost(message, optional, tag = "1")]
    pub auth: ::core::option::Option<RequestAuthInfo>,
    /// a list of DHTID search keys encoded as bytes
    #[prost(bytes = "vec", repeated, tag = "2")]
    pub keys: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    /// optional, same behavior as in DHT.ping
    #[prost(message, optional, tag = "3")]
    pub peer: ::core::option::Option<NodeInfo>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FindResult {
    /// NONE |      REGULAR     | DICTIONARY
    #[prost(enumeration = "ResultType", tag = "1")]
    pub r#type: i32,
    /// n/a  | serialized value | serialized DictionaryDHTValue with serialized fields
    #[prost(bytes = "vec", tag = "2")]
    pub value: ::prost::alloc::vec::Vec<u8>,
    /// n/a  | expiration time  | DictionaryDHTValue.latest_expiration_time
    #[prost(double, tag = "3")]
    pub expiration_time: f64,
    /// two aligned arrays: DHTIDs and PeerIDs for nearest peers (sorted by XOR distance)
    ///
    /// DHTIDs of the nearest peers serialized with node_id.to_bytes()
    #[prost(bytes = "vec", repeated, tag = "4")]
    pub nearest_node_ids: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    /// libp2p PeerIDs of the nearest peers
    #[prost(bytes = "vec", repeated, tag = "5")]
    pub nearest_peer_ids: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FindResponse {
    #[prost(message, optional, tag = "1")]
    pub auth: ::core::option::Option<ResponseAuthInfo>,
    /// for each item, return value/expiration (if found) and nearest peers
    #[prost(message, repeated, tag = "2")]
    pub results: ::prost::alloc::vec::Vec<FindResult>,
    /// respondent's node id, for you to update routing table
    #[prost(message, optional, tag = "3")]
    pub peer: ::core::option::Option<NodeInfo>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ResultType {
    NotFound = 0,
    FoundRegular = 1,
    FoundDictionary = 2,
}
impl ResultType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ResultType::NotFound => "NOT_FOUND",
            ResultType::FoundRegular => "FOUND_REGULAR",
            ResultType::FoundDictionary => "FOUND_DICTIONARY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "NOT_FOUND" => Some(Self::NotFound),
            "FOUND_REGULAR" => Some(Self::FoundRegular),
            "FOUND_DICTIONARY" => Some(Self::FoundDictionary),
            _ => None,
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TestRequest {
    #[prost(int32, tag = "1")]
    pub number: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TestResponse {
    #[prost(int32, tag = "1")]
    pub number: i32,
}
